We are developing in our team a CRUD REST API. We started the development Quarkus 1 and Kotlin and later updated to Quarkus 2. Since July 2023 Quarkus 3.2 is the current [LTS release](https://quarkus.io/blog/lts-releases/). Thus, we wanted to update our app as soon as possible to remain on a proper long term release.

![Easy upgrade](https://dev-to-uploads.s3.amazonaws.com/uploads/articles/1fpd17p5aahvg3ojps2m.png)

## Update (almost) easy Quarkus-cli

The official documentation recommends to update using the quarkus-cli. Howerver, this did not work on our project. Maybe because it was not created using the quarkus starter or because we touched too much on the pom file XD. For example, we were not using the Quarkus BOM and we were specifying the version on each quarkus library.

In any case, I wanted to have a state-of-art project which is quarkus-cli friendly. In order to do that, I created a new project by using [code.quarkus.io](https://code.quarkus.io/) and by selecting all the extensions that we use: Kotlin, Postgres and Panache. After that, I replaced our pom with the one generated by [code.quarkus.io](https://code.quarkus.io/). I also had to add some specific libraries that we use and that were not available as extensions.

After updating the pom and checking that the project still compiles, I tried to use the quarkus-cli again and the update went correctly smoothly. For example, the update tool renamed all javax imports to jakarta.

The REST API was running again. Yay! The next step was to check if there no regressions on runtime or testing.

## Issues encountered after the upgrade

Can you guess if we encountered issues ? Of course yes!

Actually, most of the bugs that we had came from migrating Hibernate from version 5 to version 6. This was to be expected since Quarkus provided two migration guides ([this one](https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0#jpa--hibernate-orm), and [this other one](https://github.com/quarkusio/quarkus/wiki/Migration-Guide-3.0:-Hibernate-ORM-5-to-6-migration)) just for Hibernate. Of course, I didn't read beforehand ü§¶‚Äç‚ôÇÔ∏è.

Here is a listing of the errors that we got and how we fixed them:

- Composite Keys require to implement Comparable or they fail to  instantiante
- Panache queries were we use a foreign key's column name instead of a JPQL join failed after migrating to Hibernate 6. So I replaced them with joins and this fixed it. In any case, I find it weird that Hibernate 5 was ok with this in the first place.
- A non-lazy OneToMany fields started to generate cryptic errors. A fortunate forum post gave me the hint to set the fetchType to Lazy and the error was magically fixed

### @GeneratedValue

We were using a `@GeneratedValue` which was referncing an implicit `hibernate_sequence` which was automatically generated by Hibernate. 
  ```kt
  @Id
  @GeneratedValue(
      strategy = GenerationType.SEQUENCE,
      generator = "hibernate_sequence"
  )
  var id: Long = 0
  ```

This was causing issues with the allocation size (the range of ids that managed by the Hibernate) which was not in sync between hibernate and the database squence linked to it.
To put it simply, Hibernate optimizes requests for the next id the sequence by managing a set of ids internally which is called `allocationSize`. 
For example, if the next number of the database squenece is 5 and `allocationSize`, then Hibernate will internally manage the autoincrement from 5 to 14 (or 15 I'm not sure here :)). 
When it reaches the next id, it will request the next database sequence
We fixed this by explicitly specifing the allocation size in code and 

Si our code we added a `@SequenceGenerator` annotation
  ```kotlin
  @Id
  @GeneratedValue(
      strategy = GenerationType.SEQUENCE,
      generator = "registration_id_seq"
  )
  @SequenceGenerator(
      name = "registration_id_seq",
      sequenceName = "hibernate_sequence",
      allocationSize = 10
  )
  var id: Long = 0
  ```

And in the database we set the increment of the sequence with the same aount of the allocation size. 
We achieved this by running this SQL script `ALTER SEQUENCE hibernate_sequence INCREMENT BY 10;`.

Most of them were easy to understand and fix, but the last of the was not. After fixing those issues, the project was running well and we didn't encouter anymore migration issues.

## Conclusion

Upgrading our Quarkus project from version 2 to version 3 went globally very smoothly given the legacy that we had. Our most blocking points were the pom which was not friendly with upgrade tool and the migration from Hibernate 5 to 6. The lesson that I learn si to not understimate the migration impacts of a dependency which can be stronger than the framework that used it.

Happy coding !
