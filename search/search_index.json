{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Bienvenue au cours \"D\u00e9veloppement Java\"","text":"","tags":["introduction"]},{"location":"#introduction","title":"Introduction","text":"","tags":["introduction"]},{"location":"#pre-requis","title":"Pr\u00e9-requis","text":"<ul> <li>Installer Java via un gestionnaire de paquets (je vous d\u00e9conseille d'utiliser l'installateur officiel)<ul> <li>Sous Windows via scoop</li> <li>Sous macOS ou Linux via SDKMAN!</li> </ul> </li> <li>Visual studio Code (VSCode) et l'extension pack java.</li> </ul>","tags":["introduction"]},{"location":"#ressources-et-liens-utiles","title":"Ressources et liens utiles","text":"<ul> <li>emojipedia</li> <li>Complete list of github markdown emoji markup</li> <li>mkdocs material</li> </ul>","tags":["introduction"]},{"location":"#license-credits-et-remerciements","title":"License, cr\u00e9dits et remerciements","text":"<ul> <li>Le cours est r\u00e9alis\u00e9 avec MKDocs et Material for MKDocs</li> <li>Ce support de cours est disponible sous licence Creative Commons Attribution 4.0 International (CC BY 4.0)</li> <li>Certaines images sont g\u00e9n\u00e9r\u00e9es via IA (Hotpot.ai)</li> </ul>","tags":["introduction"]},{"location":"distrib/","title":"Programmation distribu\u00e9e","text":"<ul> <li>vs microservices:<ul> <li>microservices: une approche de conception o\u00f9 une application est divis\u00e9e en plusieurs services plus petits qui peuvent \u00eatre d\u00e9ploy\u00e9s ind\u00e9pendamment.</li> <li>syst\u00e8mes distribu\u00e9s: compos\u00e9s de plusieurs ordinateurs qui travaillent ensemble pour effectuer une t\u00e2che unique.</li> </ul> </li> <li>vs parall\u00e9lisme</li> </ul>"},{"location":"distrib/#sources","title":"Sources","text":"<ul> <li>What Are Distributed Systems?</li> <li>The Top Distributed Data Processing Technologies: A Comprehensive Overview</li> <li>Qu'est-ce qu'un syst\u00e8me distribu\u00e9 ?</li> </ul>"},{"location":"java-exercices-1/","title":"Exercices initiaux","text":"<p>Consignes</p> <ul> <li>Ne pas de faire aider par des IA ou genAI</li> </ul>"},{"location":"java-exercices-1/#exercice-1","title":"Exercice 1","text":"<p>Cr\u00e9er un programme Java qui permet de jouer \u00e0 pile ou face, le programme lance une pi\u00e8ce au hasard et demande \u00e0 l'utilisateur de saisir pile ou face au clavier. Le programme affiche le r\u00e9sultat et si l'utilisateur a gagn\u00e9 ou perdu.</p> Guess the number <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\nimport java.util.Scanner;\nimport java.util.random.RandomGenerator;\n\npublic class GuessNumber {\n\n  public static void main(String... args) {\n    // var permet de faire du typage implicite\n    var randomGenerator = RandomGenerator.getDefault();\n    int numberToGuess = randomGenerator.nextInt(1, 21);\n\n    Scanner scanner = new Scanner(System.in);\n\n    int proposition = scanner.nextInt();\n    while (proposition != numberToGuess) {\n      if (proposition &lt; numberToGuess) {\n        System.out.println(\"Plus\");\n      } else {\n        System.out.println(\"Moins\");\n      }\n      proposition = scanner.nextInt();\n    }\n    System.out.println(\"Gagn\u00e9\");\n    scanner.close();\n  }\n}\n</code></pre>"},{"location":"java-exercices-1/#exercice-2","title":"Exercice 2","text":"<p>Cr\u00e9er un programme Java qui permet de jouer au jeu de \"devine un nombre\". Le programme g\u00e9n\u00e8re un nombre al\u00e9atoire entre 1 et 20 (1 et 20 sont inclus) et demande \u00e0 l'utilisateur de deviner ce nombre. Le programme affiche, pour chaque proposition de l'utilisateur, si le nombre est plus grand ou plus petit que le nombre choisi. Si l'utilisateur trouve le nombre, Le programme affiche le nombre d'essais qu'il lui a fallu pour trouver ce nombre.</p> Heads or Tails <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\nimport java.util.Scanner;\nimport java.util.random.RandomGenerator;\n\npublic class HeadsOrTails {\n\n  public static void main(String... args) {\n\n    var randomGenerator = RandomGenerator.getDefault();\n    boolean isHeads = randomGenerator.nextBoolean();\n    // Op\u00e9rateur ternaire ? : (ternainre: trois op\u00e9randes)\n    String side = isHeads ? \"pile\" : \"face\";\n    // \u00e9quivalent \u00e0 \u00e7a\n    if (isHeads) {\n      side = \"pile\";\n    } else {\n      side = \"face\";\n    }\n\n    var s = new Scanner(System.in);\n    var answer = s.nextLine();\n    s.close();\n\n    System.out.println(side);\n\n    if (side.equals(answer)) {\n      System.out.println(\"Gagn\u00e9\");\n    } else {\n      System.out.println(\"perdu\");\n    }\n  }\n}\n</code></pre>"},{"location":"java-exercices-1/#exercice-3","title":"Exercice 3","text":"<p>\u00c9crire un programme Java qui permet d'afficher l'inverse d'une cha\u00eene de caract\u00e8res. Par exemple, si l'utilisateur saisit \"Bonjour\", le programme affiche \"ruojnoB\". Ne pas utiliser de m\u00e9thodes de la classe String (comme reverse).</p> <p>La cha\u00eene en entr\u00e9e est pass\u00e9 en argument de la ligne de commande.</p> Reverse a string <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\npublic class ReverseManual {\n\n  public static void main(String... args) {\n    if (args.length == 0) {\n      System.err.println(\"Usage: ReverseManual inputString\");\n      exit(1);\n    }\n\n    // R\u00e9cup\u00e9ration de l'argument pass\u00e9 en ligne de commande\n    String input = args[0];\n    String output = \"\";\n    // StringBuffer propose la m\u00e9thode setCharAt non disponible dans String\n    StringBuffer reversedStringBuffer = new StringBuffer();\n    reversedStringBuffer.setLength(input.length());\n\n    for (int i = 0; i &lt; input.length(); i++) {\n      output = input.charAt(i) + output;\n      reversedStringBuffer.setCharAt(input.length() - i - 1, input.charAt(i));\n    }\n\n    System.out.println(\"solution 1: \" + output);\n    System.out.println(\"solution 2: \" + reversedStringBuffer);\n  }\n}\n</code></pre> Reverse many strings <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\npublic class ReverseManualMany {\n\n  public static void main(String... args) {\n    if (args.length == 0) {\n      System.err.println(\"Usage: ReverseManual inputString\");\n      exit(1);\n    }\n\n    for (String input : args) {\n      String output = \"\";\n      for (int i = 0; i &lt; input.length(); i++) {\n        output = input.charAt(i) + output;\n      }\n\n      System.out.println(output);\n    }\n  }\n}\n</code></pre>"},{"location":"java-exercices-1/#exercice-4","title":"Exercice 4","text":"<p>\u00c9crire un programme Java qui permet de dire si une cha\u00eene de caract\u00e8res est un palindrome. Un palindrome est un mot qui se lit de la m\u00eame fa\u00e7on de gauche \u00e0 droite et de droite \u00e0 gauche. Par exemple, \"radar\" est un palindrome. Ne pas utiliser de m\u00e9thode de la classe String. Faire l'exercice avec et sans la m\u00e9thode <code>equals</code>.</p> <p>La cha\u00eene en entr\u00e9e est pass\u00e9 en argument de la ligne de commande.</p> <p>Exemples:</p> <ul> <li>Si on passe \"radar\" en entr\u00e9e, le programme affiche \"Palindrome\"</li> <li>Si on passe \"bonjour\" en entr\u00e9e, le programme affiche \"Pas un palindrome\"</li> </ul> Palindrome <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\npublic class Palindrome {\n\n  public static boolean isPalindromeWithEquals(String input) {\n    String reversed = \"\";\n    for (int i = 0; i &lt; input.length(); i++) {\n      reversed = input.charAt(i) + reversed;\n    }\n    return input.equalsIgnoreCase(reversed);\n  }\n\n  public static boolean isPalindromeWithoutEquals(String input) {\n    for (int i = 0; i &lt; input.length() / 2; i++) {\n      if (input.charAt(i) != input.charAt(input.length() - 1 - i)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public static void main(String... args) {\n    if (args.length == 0) {\n      System.err.println(\"Usage: Palindrome inputString\");\n      exit(1);\n    }\n    System.out.println(\"Is palindrome with equals\");\n    System.out.println(isPalindromeWithEquals(args[0]) ? \"Palindrome\" : \"Pas un Palindrome\");\n    System.out.println(\"Is palindrome without equals: \");\n    System.out.println(isPalindromeWithoutEquals(args[0]) ? \"Palindrome\" : \"Pas un Palindrome\");\n  }\n}\n</code></pre>"},{"location":"java-exercices-1/#exercice-5","title":"Exercice 5","text":"<p>\u00c9crire un programme Java qui permet de saisir un nombre entier et de calculer la somme de ses chiffres. Le programme affiche la somme des chiffres ainsi que le d\u00e9tail du calcul.</p> <p>Le nombre en entr\u00e9e est pass\u00e9 en argument de la ligne de commande.</p> <p>Exemples :</p> <ul> <li>Si on passe 123 en entr\u00e9e, le programme affiche \"6 (1 + 2 + 3 = 6)\"</li> <li>Si on passe 1234 en entr\u00e9e, le programme affiche \"10 (1 + 2 + 3 + 4 = 10)\"</li> </ul> Count digits <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\npublic class CountDigits {\n\n  public static void main(String... args) {\n    if (args.length == 0) {\n      System.err.println(\"Usage: CountDigits inputNumber\");\n      exit(1);\n    }\n    int input = Integer.parseInt(args[0]);\n    String detail = \" (\";\n    int sum = 0;\n    // Pour ne pas afficher le + dans le d\u00e9tail du calcul du premier nombre\n    boolean isFirst = true;\n    while (input != 0) {\n      int digit = input % 10;\n      String prefix = isFirst ? \"\" : \" + \";\n      detail += prefix + digit;\n      isFirst = false;\n      input = input / 10;\n      sum += digit;\n    }\n    detail += \")\";\n\n    System.out.println(sum + detail);\n  }\n}\n</code></pre>"},{"location":"java-exercices-1/#exercice-6","title":"Exercice 6","text":"<p>Cr\u00e9er un programme Java qui permet de saisir un entier et de v\u00e9rifier si cet entier est un nombre premier.</p> <p>Le nombre en entr\u00e9e est r\u00e9cup\u00e9r\u00e9 via le <code>Scanner</code>.</p> <p>Rappel : un nombre premier est un nombre qui qui est divisible par exactement deux entiers disctints (qui sont 1 et le nombre-m\u00eame). 0 et 1 ne sont pas des nombres premiers par d\u00e9finition (1 n'est pas divisible par deux nombres distincts).</p> Is prime ? <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\nimport java.util.Scanner;\n\npublic class IsPrime {\n\n  public static void main(String... args) {\n    System.out.println(\"Veuillez saisir un entier positif et on vous dira s'il est premier.\");\n\n    Scanner scanner = new Scanner(System.in);\n    long input = scanner.nextLong();\n    scanner.close();\n    if (input &lt; 0) {\n      System.err.println(\"ce n'est pas un nombre positif\");\n      exit(1);\n    } else if (input &lt; 2) {\n      System.out.println(\"ce n'est pas un nombre premier\");\n      exit(1);\n    } else if (input == 2) {\n      System.out.println(\"c'est un nombre premier\");\n      exit(0);\n    }\n\n    for (long i = 2; i &lt; input / 2; i++) {\n      if (input % i == 0) {\n        System.out.println(\"Ce n'est pas un nombre premier\");\n        exit(1);\n      }\n    }\n    System.out.println(\"C'est un nombre premier\");\n  }\n}\n</code></pre>"},{"location":"java-exercices-2/","title":"Exercices sur les tableaux","text":"<p>Consignes</p> <ul> <li>Ne pas de faire aider par des IA ou genAI</li> </ul>"},{"location":"java-exercices-2/#exercice-1","title":"Exercice 1","text":"<ul> <li>Cr\u00e9er un programme Java qui g\u00e9n\u00e8re un tableau al\u00e9atoire de 10 entiers compris entre -10 et 10 et affiche (Il faut calculer vous-m\u00eame les valeurs avec une boulce for) :</li> <li>La plus grande valeur</li> <li>La plus petite valeur</li> <li>La moyenne</li> <li>L'\u00e9cart type dont la formule est : <code>racine carr\u00e9e (somme((x - moyenne)\u00b2) / n)</code></li> <li>Le nombre de valeurs positives et le nombre de valeurs n\u00e9gatives</li> <li>Le nombre de valeurs paires et le nombre de valeurs impaires</li> </ul> S\u00e9rie 2 exo 1 <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport java.util.random.RandomGenerator;\n\npublic class Serie2Ex1 {\n\n  public static void main(String... args) {\n    int numbers[] = new int[10];\n    RandomGenerator rng = RandomGenerator.getDefault();\n    int sum = 0;\n    int oddCount = 0; // odd : impair\n    int evenCount = 0; // even : pair\n    // g\u00e9n\u00e9ration et calcul de la somme\n    for (int i = 0; i &lt; numbers.length; i++) {\n      numbers[i] = rng.nextInt(-10, 10);\n      System.out.print(numbers[i] + \", \");\n      sum += numbers[i];\n      if (numbers[i] % 2 == 0) {\n        evenCount += 1;\n      } else {\n        oddCount += 1;\n      }\n    }\n    // min, max, \u00e9crat type\n    int min = numbers[0];\n    int max = numbers[0];\n    double standardDeviation = 0; // ecart type\n    double average = (double) sum / (double) numbers.length;\n    for (int i = 0; i &lt; numbers.length; i++) {\n      standardDeviation += Math.pow(numbers[i] - average, 2);\n      if (min &gt; numbers[i]) {\n        min = numbers[i];\n      } else if (max &lt; numbers[i]) {\n        max = numbers[i];\n      }\n    }\n    standardDeviation = Math.sqrt(standardDeviation / (double) numbers.length);\n    System.out.println(\"\\nResults -&gt;\");\n    System.out.println(\"min: \" + min + \", max:\" + max);\n    System.out.println(\"Even count: \" + evenCount + \", Odd count:\" + oddCount);\n    System.out.println(\"sum: \" + sum + \", Standard deviation:\" + standardDeviation);\n  }\n}\n</code></pre>"},{"location":"java-exercices-2/#exercice-2","title":"Exercice 2","text":"<p>Cr\u00e9er une programme Java qui met dans un tableau les 10 premiers nombres premiers posifitfs.</p> <p>Rappel : un nombre premier est un nombre qui qui est divisible par exactement deux entiers disctints (qui sont 1 et le nombre-m\u00eame). 0 et 1 ne sont pas des nombres premiers par d\u00e9finition (1 n'est pas divisible par deux nombres distincts).</p> 10 premiers nombres premiers <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\npublic class First10Prime {\n\n  public static void main(String... args) {\n    System.out.println(\"Hello World\");\n\n    int[] firstTenPrimes = new int[10];\n    firstTenPrimes[2] = 2;\n    int i = 1;\n    for (int currentInt = 3; i &lt; firstTenPrimes.length; currentInt++) {\n\n      // check if currentInt is prime\n      int j = 2;\n      for (; j &lt; currentInt; j++) {\n        if (currentInt % j == 0) {\n          break;\n        }\n      }\n      if (j == currentInt) {\n        firstTenPrimes[i] = currentInt;\n        i++;\n      }\n    }\n\n    System.out.println(\"R\u00e9sutat -&gt;\");\n    for (int j = 0; j &lt; firstTenPrimes.length; j++) {\n      System.out.print(firstTenPrimes[j] + \", \");\n    }\n  }\n}\n</code></pre>"},{"location":"java-exercices-2/#exercice-3","title":"Exercice 3","text":"<p>Cr\u00e9er un fonctione Java qui calcule le schtroumph de deux tableaux qui ne sont pas forc\u00e9ment de la m\u00eame taille (source). Pour calculer le schtroumpf, il faut multiplier chaque \u00e9l\u00e9ment du premier tableau par chaque \u00e9l\u00e9ment du deuxi\u00e8me, et additionner le tout. Par exemple si l'on a :</p> <ul> <li>Tableau 1 : 4 8 7 12</li> <li>Tableau 2 : 3 6</li> <li>Le Schtroumpf sera : 3 \u2217 4 + 3 \u2217 8 + 3 \u2217 7 + 3 \u2217 12 + 6 \u2217 4 + 6 \u2217 8 + 6 \u2217 7 + 6 \u2217 12 = 279</li> </ul> <p>Cr\u00e9er un programme Java qui g\u00e9n\u00e8re deux tableaux al\u00e9atoires (de valeurs de entre -10 et 10 inclus) de taille al\u00e9atoire ( 2 &lt;= nombre d'\u00e9l\u00e9ments &lt; 5) et qui calcule leur schtroumpf.</p> Schtroumphons \ud83d\udcbb <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\nimport java.util.random.RandomGenerator;\n\npublic class Schtroumph2Arrays {\n\n  public static int compute(int[] leftItems, int[] rightItems) {\n    int restult = 0;\n    for (int i = 0; i &lt; rightItems.length; i++) {\n      for (int j = 0; j &lt; leftItems.length; j++) {\n        int mulitplication = rightItems[i] * leftItems[j];\n        restult += mulitplication;\n        System.out.print(String.format(\"%d x %d = %d\", rightItems[i], leftItems[j], mulitplication));\n        if (j &lt; leftItems.length - 1) {\n          // Ajouter un \", \" \u00e0 l'affichage pour tous les \u00e9l\u00e9ments sauf le dernier\n          System.out.print(\", \");\n        }\n      }\n      System.out.println();\n    }\n    return restult;\n  }\n\n  public static int[] generateRandomArray() {\n    RandomGenerator randomGenerator = RandomGenerator.getDefault();\n    int length = randomGenerator.nextInt(2, 5);\n    int[] numbers = new int[length];\n    System.out.print(\"[\");\n    for (int i = 0; i &lt; numbers.length; i++) {\n      numbers[i] = randomGenerator.nextInt(-10, 10);\n      System.out.print(numbers[i]);\n      if (i != length - 1) {\n        // Ajouter un \", \" \u00e0 l'affichage pour tous les \u00e9l\u00e9ments sauf le dernier\n        System.out.print(\", \");\n      }\n    }\n    System.out.println(\"]\");\n    return numbers;\n  }\n\n  public static void main(String... args) {\n    System.out.println(\"Tableaux donn\u00e9s en exemple\");\n    int[] exampleLeftItems = new int[] { 4, 8, 7, 12 };\n    int[] exampleRightItems = new int[] { 3, 6 };\n    int exampleResult = compute(exampleLeftItems, exampleRightItems);\n    System.out.println(exampleResult);\n\n    System.out.println(\"Tableaux al\u00e9atoires\");\n    int[] rightItems = generateRandomArray();\n    int[] leftItems = generateRandomArray();\n    int result = compute(leftItems, rightItems);\n    System.out.println(result);\n  }\n}\n</code></pre>"},{"location":"java-exercices-2/#exercice-4","title":"Exercice 4","text":"<ul> <li>Cr\u00e9er une fonction qui prend un tableau d\u2019entiers \u201cint[] numbers\u201d et affiche la plus grande valeur et la plus petite valeur (Il faut calculer vous-m\u00eame le max et le min)</li> <li>G\u00e9n\u00e9rer un tableau de 10 entier al\u00e9atoires et afficher le max et le min</li> <li> <p>G\u00e9n\u00e9rer un tableau de 10 entiers saisis au clavier et afficher le max et le min</p> </li> <li> <p>Supposons qu'on ait deux cercles : un cercle de centre A et de rayon Ra, et un cercle de centre B et de rayon Rb. Les coordonn\u00e9es de A sont not\u00e9es (xa, ya) et les coordonn\u00e9es de B sont not\u00e9es (xb, yb). On souhaite \u00e9crire un algorithme (tr\u00e8s simple) permettant de dire si les deux cercles se rentrent dedans. La distance entre les deux centres A et B est: <code>sqrt((xb-xa)\u00b2 + (yb-ya)\u00b2)</code></p> <ul> <li>Donner la condition qui permet de savoir s\u2019il y a collision (ou pas) entre les cercles</li> <li>Exprimer cette condition sans racine carr\u00e9e</li> <li>Ecrire une fonction <code>isCollision</code> qui prend les informations de deux cercles en arguments et renvoie <code>true</code> s\u2019il y a collision entre les deux cercles, sinon <code>false</code>.</li> <li>Faire cet exercice en d\u00e9finissant une classe Circle et <code>isCollision</code> comme une m\u00e9thode de cette classe</li> </ul> </li> </ul> Random min and max <pre><code>///usr/bin/env jbang --enable-preview \"$0\" \"$@\" ; exit $?\n\nimport java.util.random.RandomGenerator;\nimport static java.lang.System.*;\n\npublic class RandomMinMax {\n\n  public static void printMinMax(int[] numbers) {\n    if (numbers.length == 0) {\n      return;\n    }\n\n    int min = numbers[0];\n    int max = numbers[0];\n\n    for (int number : numbers) {\n      min = number &lt; min ? number : min;\n      max = number &gt; max ? number : max;\n    }\n    System.out.println(String.format(\"min: %d, max: %d\", min, max));\n  }\n\n  public static void main(String... args) {\n    RandomGenerator generator = RandomGenerator.getDefault();\n    int[] numbers = new int[10];\n    for (int i = 0; i &lt; numbers.length; i++) {\n      numbers[i] = generator.nextInt();\n      System.out.print(String.format(\"%d, \", numbers[i]));\n    }\n    System.out.println();\n    printMinMax(numbers);\n  }\n}\n</code></pre> CircleCollisionDetector <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\npublic class CircleCollisionDetector {\n  public static void main(String[] args) {\n    CircleCollisionDetector circleCollisionDetector = new CircleCollisionDetector();\n    circleCollisionDetector.isColliding(0, 0, 10, 10, 0, 10);\n  }\n\n  /**\n   * La distance entre les deux cercles est plus petite que la somme des rayons\n   * \n   * @param xa\n   * @param ya\n   * @param ra\n   * @param xb\n   * @param yb\n   * @param rb\n   * @return\n   */\n  boolean isColliding(int xa, int ya, int ra, int xb, int yb, int rb) {\n    return Math.pow(xb - xa, 2) + Math.pow(yb - ya, 2) &lt; Math.pow(rb + ra, 2);\n  }\n}\n</code></pre>"},{"location":"java-exercices-3/","title":"Exercices sur les streams","text":"<p>Consignes</p> <ul> <li>Ne pas de faire aider par des IA ou genAI</li> </ul>"},{"location":"java-exercices-3/#exercice-1","title":"Exercice 1","text":"<ul> <li>On souhaite mod\u00e9liser une collection de consoles et jeux r\u00e9tro. Les consoles (classe <code>VideoGameConsole</code>) et les jeux r\u00e9tro (classe <code>VideoGame</code>) sont des appareils de divertissement ayant les propri\u00e9t\u00e9s: <code>name</code>, <code>releaseYear</code> en commun. Les consoles ont en plus la propri\u00e9t\u00e9: <code>companyName</code> (la soci\u00e9t\u00e9 qui l'a cr\u00e9\u00e9). Les jeux vid\u00e9os ont comme propri\u00e9t\u00e9 suppl\u00e9mentaire l'\u00e9diteur du jeu (celui qui le distribue) ainsi que son d\u00e9veloppeur. On aimerait aussi savoir s'il est ind\u00e9pendant ou pas.</li> <li>D\u00e9finir les classes n\u00e9cessaires.</li> <li>Chaque jeu vid\u00e9o tient une liste des consoles compatibles (pour les jeux cross-platform) via la propri\u00e9t\u00e9: <code>platforms</code>.</li> <li><code>VideoGameConsole</code> contient en plus la propri\u00e9t\u00e9: <code>companyName</code> de type string.</li> <li>Compl\u00e9ter la d\u00e9finition des classes et instancier les jeux et consoles suivantes:<ul> <li>Console: <code>name: My first 16 bit Console</code>, <code>releaseYear: 1987</code>, <code>companyName: SEGA</code></li> <li>Console: <code>name: Another 16 bit console</code>, <code>releaseYear: 1991</code>, <code>companyName: Nintendo</code></li> <li>Console: <code>name: Awesome 3D console</code>, <code>releaseYear: 1996</code>, <code>companyName: Sony</code></li> <li>Console: <code>name: 3D console with weird joystick</code>, <code>releaseYear: 1997</code>, <code>companyName: Nintendo</code></li> <li>Jeu: <code>name: Alex Kidd</code>, <code>releaseYear: 1988</code>, <code>publisher: SEGA</code></li> <li>Jeu: <code>name: Sonic</code>, <code>releaseYear: 1990</code>, <code>publisher: SEGA</code></li> <li>Jeu: <code>name: Mario RPG</code>, <code>releaseYear: 1996</code>, <code>publisher: Nintendo</code></li> <li>Jeu: <code>name: Final Fantasy 6</code>, <code>releaseYear: 1994</code>, <code>publisher: Square</code></li> </ul> </li> <li>En utilisant les streams:<ul> <li>Afficher les jeux sortis \u00e0 partir de l'ann\u00e9e 1990 tri\u00e9s par ordre croissant de l'ann\u00e9e.</li> <li>Afficher le nom des consoles de la compagnie SEGA.</li> <li>Afficher le nom des consoles dont le nom contient le mot 16 bits.</li> <li>Le nom du premier jeu sorti</li> <li>Trouver le nombre de jeux de chaque \u00e9diteur en calculant dictionnaire dont la cl\u00e9 est l'\u00e9diteur ou son nom et en valeur le nombre de jeux</li> <li>Pour chaque \u00e9diteur, l'ann\u00e9e de sortie du premier jeu en calculant dictionnaire dont la cl\u00e9 est l'\u00e9diteur ou son nom et en valeur une ann\u00e9e</li> </ul> </li> </ul> Corrig\u00e9 <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\n//DEPS com.google.guava:guava:33.1.0-jre\n\nimport java.util.AbstractMap;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.google.common.base.Joiner;\n\nabstract class EntertainmentDevice {\n  private String name;\n  private int releaseYear;\n\n  public EntertainmentDevice(String name, int releaseYear) {\n    this.name = name;\n    this.releaseYear = releaseYear;\n  }\n\n  // propri\u00e9t\u00e9 calcul\u00e9e\n  public boolean isAfter2000() {\n    return this.getReleaseYear() &gt;= 2000;\n  }\n\n  public boolean isAfter1990() {\n    return this.getReleaseYear() &gt;= 1990;\n  }\n\n  // prori\u00e9t\u00e9 avec backieng field (le backing field est name)\n  public String getName() {\n    return name;\n  }\n\n  // prori\u00e9t\u00e9 avec backieng field (le backing field est name)\n  public void setName(String name) {\n    this.name = name;\n  }\n\n  public int getReleaseYear() {\n    return releaseYear;\n  }\n\n  public void setReleaseYear(int releaseYear) {\n    this.releaseYear = releaseYear;\n  }\n}\n\nclass VideoGameConsole extends EntertainmentDevice {\n  private String companyName;\n\n  public VideoGameConsole(String name, int releaseYear, String companyName) {\n    super(name, releaseYear);\n    this.companyName = companyName;\n  }\n\n  public String getCompanyName() {\n    return companyName;\n  }\n\n  public void setCompanyName(String companyName) {\n    this.companyName = companyName;\n  }\n}\n\nclass VideoGame extends EntertainmentDevice {\n  private String publisher;\n\n  public VideoGame(String name, int releaseYear, String publisher) {\n    super(name, releaseYear);\n    this.publisher = publisher;\n  }\n\n  public String getPublisher() {\n    return publisher;\n  }\n\n  public void setPublisher(String publisher) {\n    this.publisher = publisher;\n  }\n\n  @Override\n  public String toString() {\n    return \"VideoGame [publisher=\" + publisher + \", getName()=\" + getName() + \", getReleaseYear()=\" + getReleaseYear()\n        + \"]\";\n  }\n\n}\n\npublic class RetroCollectionExercise {\n\n  public static void main(String... args) {\n    System.out.println(\"Retro game collection exercise\");\n    var consoles = List.of(\n        new VideoGameConsole(\"My first 16 bits Console\", 1987, \"SEGA\"),\n        new VideoGameConsole(\"Another 16 bits console\", 1991, \"Nintendo\"),\n        new VideoGameConsole(\"Awesome 3D console\", 1996, \"Sony\"),\n        new VideoGameConsole(\"3D console with weird joystick\", 1997, \"Nintendo\"));\n\n    var games = List.of(\n        new VideoGame(\"Alex Kidd\", 1988, \"SEGA\"),\n        new VideoGame(\"Starcraft 2\", 1988, \"BLIZZARD\"),\n        new VideoGame(\"Sonic\", 1990, \"SEGA\"),\n        new VideoGame(\"Mario RPG\", 1996, \"Nintendo\"),\n        new VideoGame(\"Final Fantasy 6\", 1994, \"Square\"));\n\n    var gamesAfter1990 = games.stream()\n        .filter((game) -&gt; game.getReleaseYear() &gt;= 1990)\n        .sorted(Comparator.comparingInt((game) -&gt; game.getReleaseYear()))\n        .toList();\n\n    var gamesAfter1990Bis = games.stream()\n        .filter(VideoGame::isAfter1990)\n        .sorted((g1, g2) -&gt; Integer.valueOf(g1.getReleaseYear()).compareTo(g2.getReleaseYear()))\n        .toList();\n\n    System.out.println(\"\\nQ1 - Sort by release year games after 1990\");\n    gamesAfter1990.stream().forEach((g) -&gt; System.out.println(g));\n    System.out.println(\"Q1 - Bis method\" + Joiner.on(\",\").join(gamesAfter1990Bis));\n\n    var segaConsoleNames = consoles.stream()\n        .filter((c) -&gt; c.getCompanyName().equals(\"SEGA\"))\n        .map((c) -&gt; c.getName())\n        .toList();\n    System.out.println(\"\\nQ2 - \");\n    segaConsoleNames.stream().forEach((g) -&gt; System.out.println(g));\n\n    var sixteenBitsConsoleNames = consoles.stream()\n        .filter((c) -&gt; c.getName().contains(\"16 bits\"))\n        .map((c) -&gt; c.getName())\n        .toList();\n\n    System.out.println(\"\\nQ3 - 16 bits consoles: \");\n    sixteenBitsConsoleNames.stream().forEach((g) -&gt; System.out.println(\"- \" + g));\n\n    System.out.println(\"\\nQ4 - Nom du premier jeu sorti : \");\n    Optional&lt;VideoGame&gt; minYearVideoGame = games.stream().min(Comparator.comparingInt((game) -&gt; game.getReleaseYear()));\n    if (!minYearVideoGame.isPresent()) {\n      return;\n    }\n    System.out.println(minYearVideoGame.get().getName());\n\n    var minYearVideosGames = games.stream()\n        .filter((g) -&gt; g.getReleaseYear() == minYearVideoGame.get().getReleaseYear()).toList();\n    System.out.println(\"\\nQ4 ++ - Au cas o\u00f9 il y a plusieurs jeux sortis la m\u00eame ann\u00e9e : \");\n    System.out.println(Joiner.on(\",\").join(minYearVideosGames));\n\n    System.out.println(\"\\nQ5 - Nombre de jeux de chaque \u00e9diteur : \");\n    var publishers = games.stream().map(g -&gt; g.getPublisher()).distinct().toList();\n\n    var groupedGamesByPublishers = games.stream()\n        .collect(Collectors.groupingBy((g) -&gt; g.getPublisher()))\n        .entrySet().stream()\n        .map((entry) -&gt; new AbstractMap.SimpleEntry&lt;String, Integer&gt;(entry.getKey(), entry.getValue().size())).toList();\n    System.out.println(Joiner.on(\",\").join(groupedGamesByPublishers));\n\n  }\n}\n</code></pre> <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\n//DEPS com.google.guava:guava:33.1.0-jre\n\nimport java.util.AbstractMap;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport java.util.stream.Collectors;\n\nimport com.google.common.base.Joiner;\n\ninterface EntertainmentDevice {\n\n  int getReleaseYear();\n\n  // propri\u00e9t\u00e9 calcul\u00e9e\n  default public boolean isAfter2000() {\n    return this.getReleaseYear() &gt;= 2000;\n  }\n\n  default public boolean isAfter1990() {\n    return this.getReleaseYear() &gt;= 1990;\n  }\n}\n\nrecord VideoGameConsole(String name, int releaseYear, String companyName) implements EntertainmentDevice {\n  @Override\n  public int getReleaseYear() {\n    return this.releaseYear();\n  }\n}\n\nrecord VideoGame(String name, int releaseYear, String publisher) implements EntertainmentDevice {\n  @Override\n  public int getReleaseYear() {\n    return this.releaseYear();\n  }\n}\n\npublic class VideoGameCollectionWithRecords {\n\n  public static void main(String... args) {\n    System.out.println(\"Retro game collection exercise\");\n\n    var consoles = List.of(\n        new VideoGameConsole(\"My first 16 bits Console\", 1987, \"SEGA\"),\n        new VideoGameConsole(\"Another 16 bits console\", 1991, \"Nintendo\"),\n        new VideoGameConsole(\"Awesome 3D console\", 1996, \"Sony\"),\n        new VideoGameConsole(\"3D console with weird joystick\", 1997, \"Nintendo\"));\n\n    var games = List.of(\n        new VideoGame(\"Alex Kidd\", 1988, \"SEGA\"),\n        new VideoGame(\"Starcraft 2\", 1988, \"BLIZZARD\"),\n        new VideoGame(\"Sonic\", 1990, \"SEGA\"),\n        new VideoGame(\"Mario RPG\", 1996, \"Nintendo\"),\n        new VideoGame(\"Final Fantasy 6\", 1994, \"Square\"));\n\n    var gamesAfter1990 = games.stream()\n        .filter((game) -&gt; game.releaseYear() &gt;= 1990)\n        .sorted(Comparator.comparingInt((game) -&gt; game.releaseYear()))\n        .toList();\n\n    var gamesAfter1990Bis = games.stream()\n        .filter(VideoGame::isAfter1990)\n        .sorted((g1, g2) -&gt; Integer.valueOf(g1.releaseYear()).compareTo(g2.releaseYear()))\n        .toList();\n\n    var gamesAfter1990Tres = games.stream()\n        .filter((game) -&gt; game.releaseYear() &gt;= 1990)\n        .sorted((game1, game2) -&gt; {\n          if (game1.releaseYear() &gt; game2.releaseYear()) {\n            return 1;\n          } else if (game1.releaseYear() == game2.releaseYear()) {\n            return 0;\n          } else {\n            return -1;\n          }\n        })\n        .toList();\n\n    System.out.println(\"\\nQ1 - Sort by release year games after 1990\");\n    gamesAfter1990.stream().forEach((g) -&gt; System.out.println(g));\n    System.out.println(\"Q1 - Bis method\" + Joiner.on(\",\").join(gamesAfter1990Bis));\n\n    var segaConsoleNames = consoles.stream()\n        .filter((c) -&gt; c.companyName().equals(\"SEGA\"))\n        .map((c) -&gt; c.name())\n        .toList();\n    System.out.println(\"\\nQ2 - \");\n    segaConsoleNames.stream().forEach((g) -&gt; System.out.println(g));\n\n    var sixteenBitsConsoleNames = consoles.stream()\n        .filter((c) -&gt; c.name().contains(\"16 bits\"))\n        .map((c) -&gt; c.name())\n        .toList();\n\n    System.out.println(\"\\nQ3 - 16 bits consoles: \");\n    sixteenBitsConsoleNames.stream().forEach((g) -&gt; System.out.println(\"- \" + g));\n\n    System.out.println(\"\\nQ4 - Nom du premier jeu sorti : \");\n    Optional&lt;VideoGame&gt; minYearVideoGame = games.stream().min(Comparator.comparingInt((game) -&gt; game.releaseYear()));\n    if (!minYearVideoGame.isPresent()) {\n      return;\n    }\n    System.out.println(minYearVideoGame.get().name());\n\n    var minYearVideosGames = games.stream()\n        .filter((g) -&gt; g.releaseYear() == minYearVideoGame.get().releaseYear()).toList();\n    System.out.println(\"\\nQ4 ++ - Au cas o\u00f9 il y a plusieurs jeux sortis la m\u00eame ann\u00e9e : \");\n    System.out.println(Joiner.on(\",\").join(minYearVideosGames));\n\n    System.out.println(\"\\nQ5 - Nombre de jeux de chaque \u00e9diteur : \");\n    var groupedGamesByPublishers = games.stream()\n        .collect(Collectors.groupingBy((g) -&gt; g.publisher()))\n        .entrySet().stream()\n        .map((entry) -&gt; new AbstractMap.SimpleEntry&lt;String, Integer&gt;(entry.getKey(), entry.getValue().size())).toList();\n    var groupedGamesByPublishers2 = games.stream()\n        .collect(Collectors.groupingBy(VideoGame::publisher, Collectors.counting()));\n    System.out.println(Joiner.on(\",\").join(groupedGamesByPublishers));\n    System.out.println(Joiner.on(\",\").join(groupedGamesByPublishers2.entrySet()));\n    groupedGamesByPublishers2.forEach((k, v) -&gt; System.out.println(k + \" number of games: \" + v));\n\n    // Map of first game for each published\n    var firstGameByPublishers = games.stream().collect(\n        Collectors.groupingBy(VideoGame::publisher,\n            Collectors.mapping(VideoGame::releaseYear, Collectors.minBy(Comparator.comparingInt(year -&gt; year)))));\n    System.out.println(\"\\nQ5 - Ann\u00e9e du premier jeu de chaque \u00e9diteur : \");\n    System.out.println(Joiner.on(\",\").join(firstGameByPublishers.entrySet()));\n  }\n}\n</code></pre>"},{"location":"java-exercices-3/#exercice-2","title":"Exercice 2","text":"<p>Les m\u00e9thodes <code>Stream.iterate</code> et <code>Stream.generate</code> combin\u00e9es avec <code>limite</code> permettent de cr\u00e9er des streams. Voici quelques exemples d'utilisation de ces m\u00e9thodes: </p> <pre><code>// This will create a stream of 10 elements starting from -4 and incrementing by 2\nStream&lt;Integer&gt; streamIterated = Stream.iterate(-4, n -&gt; n + 2).limit(10);\nstreamIterated.forEach(System.out::println);\n\n// This will create a stream of 10 randome integers between 0 and 100\nStream&lt;Integer&gt; streamGenerated2 = Stream.generate(() -&gt; RandomGenerator.getDefault().nextInt(0, 100)).limit(10);\nstreamGenerated2.forEach(System.out::println);\n</code></pre> <p>R\u00e9pondez aux questions suivantes en utilisant les streams (pas de boucle <code>for</code>):</p> <ol> <li>Cr\u00e9er un Stream de 10 entiers al\u00e9atoires compris entre -10 et 10. Afficher la somme, le min, le max et les \u00e9l\u00e9ments sup\u00e9rieurs \u00e0 la moyenne.</li> <li>Cr\u00e9er un <code>Stream&lt;Character&gt;</code> qui g\u00e9n\u00e8re 10 voyelles al\u00e9atoires. Compter le nombre de fois qu'appara\u00eet la lettre <code>a</code>.</li> </ol>"},{"location":"java-exercices-3/#exercice-3","title":"Exercice 3","text":"<p>La classe <code>IntStream</code> est une classe sp\u00e9cialis\u00e9e sur les streams d'entiers. Elle est \u00e9galement le r\u00e9sultat d'une conversion d'une string en stream (chaque caract\u00e8re est repr\u00e9sent\u00e9 par son code en entier). Voici quelques exemples d'utilisation de cette classe:</p> <pre><code>// This will create a stream of 10 elements starting from -4 and incrementing by 2\nIntStream streamIterated = IntStream.iterate(-4, n -&gt; n + 2).limit(10);\nstreamIterated.forEach(System.out::println);\n\n// This will create a stream of 10 randome integers between 0 and 100\nIntStream streamGenerated2 = IntStream.generate(() -&gt; RandomGenerator.getDefault().nextInt(0, 100)).limit(10);\nstreamGenerated2.forEach(System.out::println);\n\n//Convert a string to a stream of characters (each character is an integer)\nIntStream streamOfChars = \"hello\".chars();\nstreamOfChars.forEach(System.out::println);\n\n//count the number of l in a string\nlong count = \"hello\".chars().filter(ch -&gt; ch == 'l').count();\nSystem.out.println(count);\n</code></pre> <p>R\u00e9pondez aux questions suivantes en utilisant les streams (pas de boucle <code>for</code>):</p> <ol> <li>Calculer le nombre de voyelles dans une cha\u00eene de caract\u00e8res.</li> <li>G\u00e9n\u00e9rer un <code>IntStream</code> de 10 voyelles al\u00e9atoires. Compter le nombre de fois qu'appara\u00eet la lettre <code>a</code>.</li> <li>Calculer le nombre d'occurences de chaque lettre dans une cha\u00eene de caract\u00e8res.</li> </ol>"},{"location":"java-exercices-4/","title":"Exercices divers","text":""},{"location":"java-exercices-4/#exercice-1","title":"Exercice 1","text":"<p>Pour cet exercice, cr\u00e9er le projet avec <code>gradle init</code> et utiliser les annotations li\u00e9es \u00e0 la null safety.</p> <ul> <li>Cr\u00e9er une classe Java <code>IntCalculator</code> qui permet de faire des op\u00e9rations arithm\u00e9tiques sur des entiers \u00e0 partir d'une cha\u00eene de caract\u00e8res au format <code>op\u00e9rande1 op\u00e9ration op\u00e9rande2</code> et retourne le r\u00e9sultat de cette op\u00e9ration.<ul> <li>les op\u00e9randes sont des entiers</li> <li>Op\u00e9tation est soit +, -, / ou *</li> <li>Vous pouvez utiliser split pour s\u00e9parer les diff\u00e9rentes parties</li> <li>Utilise les streams au maximum (utiliser les boucles au minimum)</li> </ul> </li> <li>Votre calculatrice m\u00e9morise toutes les op\u00e9rations et leurs r\u00e9sultats.</li> <li>Ecrire un programme Java qui permet de soit saisir un op\u00e9ration soit afficher l'historique des op\u00e9rations selon les commandes de l'utilisateur.<ul> <li>Si l'utilisateur saisit une op\u00e9ration du type <code>op\u00e9rande1 op\u00e9ration op\u00e9rande2</code>, afficher le r\u00e9sultat et l'ajouter \u00e0 l'historique.</li> <li>Si l'utilisateur saisit <code>h</code>, afficher l'historique des op\u00e9rations.</li> <li>Si l'utilisateur saisit <code>+</code>, <code>-</code>, , afficher l'historique des op\u00e9rations pour cette op\u00e9rande.</li> <li>Si l'utilisateur saisit <code>exit</code>, le programme s'arr\u00eate.</li> <li>Si l'utilisateur saisit un entier, sa valeur est affich\u00e9e et il est rajout\u00e9 dans l'historique</li> </ul> </li> <li>G\u00e9rer les exceptions, notamment celle li\u00e9es aux erreurs de saisie</li> </ul> exemple d'ex\u00e9cution<pre><code>#  '&gt;' signifie que c'est une entr\u00e9e de l'utilisateur. Ce n'est pas un symble \u00e0 inclure dans votre saisie\n&gt; 2 + 5\n7\n&gt; 100 - 2000\n-1900\n&gt; 42\n42\n&gt; h\n2 + 5 = 7\n100 - 2000 = -1900\n42\n&gt; +\n2 + 5 = 7\n&gt; toto\nsaisie incorrecte\n&gt; 88 - 33 * 2\nsaisie incorrecte\n&gt; exit\nbye bye\n</code></pre>"},{"location":"java-exercices-4/#exercice-2","title":"Exercice 2","text":"<p>Pour cet exercice, cr\u00e9er le projet avec <code>gradle init</code> et utiliser les annotations li\u00e9es \u00e0 la null safety.</p> <ul> <li>Cr\u00e9er une classe Java <code>ImprovedIntCalculator</code> qui permet de faire des op\u00e9rations arithm\u00e9tiques sur des entiers \u00e0 partir d'une cha\u00eene de caract\u00e8res au format <code>op\u00e9rande1 op\u00e9ration op\u00e9rande2 op\u00e9ration2 op\u00e9rande3 ...</code> et retourne le r\u00e9sultat de cette op\u00e9ration.<ul> <li>les op\u00e9randes sont des entiers</li> <li>Les op\u00e9randes \u00e9crites avec l'identifiant mi ou i est un entier permet de remplacer mi par le r\u00e9sultat dans l'historique d'indice i.</li> <li>Op\u00e9ration est soit +, -, / ou *</li> <li>Utilise les streams au maximum (utiliser les boucles au minimum)</li> <li>/ et * sont plus prioritaires que + et -</li> </ul> </li> <li>Votre calculatrice m\u00e9morise toutes les op\u00e9rations et leurs r\u00e9sultats.</li> <li>Ecrire un programme Java qui permet de soit saisir un op\u00e9ration soit afficher l'historique des op\u00e9rations selon les commandes de l'utilisateur.<ul> <li>Si l'utilisateur saisit une op\u00e9ration du type <code>op\u00e9rande1 op\u00e9ration op\u00e9rande2</code>, afficher le r\u00e9sultat et l'ajouter \u00e0 l'historique.</li> <li>Si l'utilisateur saisit <code>h</code>, afficher l'historique des op\u00e9rations.</li> <li>Si l'utilisateur saisit <code>+</code>, <code>-</code>, , afficher l'historique des op\u00e9rations pour cette op\u00e9rande.</li> </ul> </li> <li>G\u00e9rer les exceptions, notamment celle li\u00e9es aux erreurs de saisie</li> </ul> exemple d'ex\u00e9cution<pre><code>#  '&gt;' signifie que c'est une entr\u00e9e de l'utilisateur. Ce n'est pas un symble \u00e0 inclure dans votre saisie\n&gt; 2 + 5\n7\n&gt; 100 - 2000 + 5\n-1895\n&gt; h\n2 + 5 = 7\n100 - 2000 + 5 = -1895\n&gt; +\n2 + 5 = 7\n100 - 2000 + 5 = -1895\n&gt; toto\nsaisie incorrecte\n&gt; 88 - 33 * 2\n22\n&gt; 88 - 33 * 2 / 3 + 5\n67\n&gt; 7 + m0\n14\n&gt; m2\n22\n&gt; exit\nbye bye\n</code></pre>"},{"location":"java-exercices-4/#exercice-3","title":"Exercice 3","text":"<p>Kotlin Heroes 2024, Problem A: 1-3-5.</p> <p>In Berland, coins of worth 1, 3 and 5 burles are commonly used (burles are local currency).</p> <p>Eva has to pay exactly \ud835\udc5b burles in a shop. She has an infinite amount of coins of all three types. However, she doesn't like to pay using coins worth 1 burle \u2014 she thinks they are the most convenient to use.</p> <p>Help Eva to calculate the minimum number of coins worth 1 burle she has to use, if she has to pay exactly \ud835\udc5b burles. Note that she can spend any number of coins worth 3 and/or 5 burles.</p> <ul> <li>Input<ul> <li>The first line contains one integer \ud835\udc61 (1\u2264\ud835\udc61\u2264100 ) \u2014 the number of test cases.</li> <li>Each test case consists of one line, containing one integer \ud835\udc5b(1\u2264\ud835\udc5b\u2264100).</li> </ul> </li> <li>Output<ul> <li>For each test case, print one integer \u2014 the minimum number of 1-burle coins Eva has to use.</li> </ul> </li> </ul> input<pre><code>5\n7\n8\n42\n2\n11\n</code></pre> output<pre><code>1\n0\n0\n2\n0\n</code></pre>"},{"location":"java-tour/","title":"Tour du langage Java","text":"<p>Nous allons faire un tour du langage Java sans forc\u00e9ment tout couvrir car il est tr\u00e8s riche en fonctionnalit\u00e9s.</p> <p>Warning</p> <p>Comme le langage Java \u00e9volue apporte fr\u00e9quemment des am\u00e9lioration et simplifications, il se peut que les exemples de code vues ici soient diff\u00e9rents de ce que vous trouvez dans la litt\u00e9rature.</p>"},{"location":"java-tour/#premiers-pas","title":"Premiers pas","text":"<pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\n//DEPS com.google.guava:guava:32.1.3-jre\n\nimport static java.lang.System.*;\n\nclass Calculator {\n  public int a;\n  public int b;\n  static double PI = 3.14;\n\n  public double add() {\n    return a + b + Calculator.PI;\n  }\n\n  static double multiply(int x, int y) {\n    return x * y * PI;\n  }\n}\n\nclass Calculator2 {\n  public int a;\n  public int b;\n\n  public int add() {\n    return a + b;\n  }\n}\n\npublic class hello {\n\n  public static void main(String... args) {\n    out.println(\"Hello World\");\n    int i = 10;\n    long j = 1_000_000;\n    var message = \"hello\";\n    message = \"world\";\n\n    var c = new Calculator();\n    c.add();\n\n    Calculator.multiply(10, 1);\n  }\n}\n</code></pre> <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\npublic class operators {\n\n  public static void main(String... args) {\n    // unary operator: takes one operand and return a value\n    System.out.println(+3);\n    int x = 55;\n    System.out.println(-x);\n    // Binary operator: takes two operands and returns a value\n    System.out.println(5 * 4);\n    System.out.println(-x / 4);\n    // % is the remainder of the division\n    System.out.println(9 % 2);\n    // Binary operators for comparison: &gt;, ==, !=, &lt;, &gt;=, &lt;= takes two comparable\n    // values (numbers and booleans in Java)\n    System.out.println(x &gt; 10);\n    // Unary operator for boolean algebra: !\n    boolean comparison = x % 5 == 0;\n    System.out.println(!comparison);\n  }\n}\n</code></pre>"},{"location":"java-tour/#classes-heritage-et-interfaces","title":"Classes, h\u00e9ritage et interfaces","text":"<pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\ninterface Gamer {\n  public void play();\n}\n\ninterface HungryEater {\n  public void eat();\n}\n\nclass Human {\n  private String name;\n\n  public Human() {\n    this(\"anonymous\");\n  }\n\n  public Human(String name) {\n    this.name = name;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public void setName(String name) {\n    this.name = name;\n  }\n}\n\nclass HumanGamer extends Human implements Gamer {\n  @Override\n  public void play() {\n    out.println(\"je joue\");\n  }\n}\n\nclass HungryGamerHuman extends Human implements HungryEater, Gamer {\n\n  @Override\n  public void eat() {\n  }\n\n  @Override\n  public void play() {\n    // TODO Auto-generated method stub\n    throw new UnsupportedOperationException(\"Unimplemented method 'play'\");\n  }\n\n}\n\nclass Lion implements HungryEater {\n  @Override\n  public void eat() {\n  }\n}\n\nclass Student extends Human {\n  private String idNumbeString;\n\n  public Student(String name, String idNumbeString) {\n    super(name);\n    this.idNumbeString = idNumbeString;\n  }\n\n  public String getIdNumberString() {\n    return idNumbeString;\n  }\n\n  public void setIdNumberString(String idNumbeString) {\n    this.idNumbeString = idNumbeString;\n  }\n}\n\npublic class ClasseInterface {\n\n  static void giveFood(HungryEater eater) {\n\n  }\n\n  static void runGame(Gamer gamer) {\n\n  }\n\n  public static void main(String... args) {\n    out.println(\"Hello World\");\n  }\n}\n</code></pre>"},{"location":"java-tour/#types-generiques","title":"Types g\u00e9n\u00e9riques","text":"<pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\nimport java.util.*;\n\nclass IntegerCalculator {\n  private Integer x;\n\n  public IntegerCalculator(Integer x) {\n    this.x = x;\n  }\n\n  Integer add(Integer b) {\n    x += b;\n    return x;\n  }\n\n  boolean isPositive() {\n    return x &gt;= 0;\n  }\n}\n\nclass GenericCalculator&lt;Toto extends Number&gt; {\n  private Toto x;\n\n  public GenericCalculator(Toto x) {\n    this.x = x;\n  }\n\n  boolean isPositive() {\n    return x.doubleValue() &gt;= 0;\n  }\n}\n\npublic class GenericsDemo {\n\n  public static void main(String... args) {\n    var c1 = new GenericCalculator&lt;Integer&gt;(Integer.valueOf(10));\n\n    List&lt;String&gt; items = new ArrayList&lt;&gt;();\n    // Java d\u00e9duit que le type du g\u00e9n\u00e9rique est \"Integer\"\n    var integers = List.of(Integer.valueOf(19));\n    System.out.println(integers);\n  }\n}\n</code></pre>"},{"location":"java-tour/#collections","title":"Collections","text":"<pre><code>///usr/bin/env jbang --enable-preview \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\nimport java.util.*;\nimport java.util.Map.Entry;\n\npublic class CollectionDemo {\n\n  public static void main(String... args) {\n    // Type de base int\n    int i = 99;\n    // Objet Integer\n    Integer j = 10;\n    System.out.println(i);\n    System.out.println(\"Integer: \" + j.compareTo(i) + \", \" + j.floatValue());\n    int[] numbers = { 1, 20, 30 };\n    List&lt;Integer&gt; items = new ArrayList&lt;&gt;();\n    items.add(-3);\n    items.add(11);\n    items.add(22);\n    var otherItems = List.of(-2, 11, 22);\n    for (int k = 0; k &lt; items.size(); k++) {\n      System.out.print(items.get(k) + \", \");\n    }\n    System.out.println();\n    Iterator&lt;Integer&gt; iter = items.iterator();\n    System.out.println(iter.next() + \", \" + iter.hasNext());\n    System.out.println(iter.next() + \", \" + iter.hasNext());\n    System.out.println(iter.next() + \", \" + iter.hasNext());\n    System.out.println();\n    System.out.println(\"Iter for loop\");\n    for (var iter2 = items.iterator(); iter2.hasNext();) {\n      Integer value = iter2.next();\n      System.out.print(value + \", \");\n    }\n    System.out.println();\n    System.out.println(\"Iter for each\");\n    for (Integer item : items) {\n      System.out.print(item + \", \");\n    }\n    System.out.println();\n\n    System.out.println(\"Map\");\n    // 6786L =&gt; Lit\u00e9ral de type long (type de base)\n    Map&lt;String, Long&gt; userIds = Map.of(\"Hugo\", 6786L, \"R\u00e9my\", 343L);\n    System.out.println(userIds.get(\"R\u00e9my\"));\n    Iterator&lt;Entry&lt;String, Long&gt;&gt; iterUserIds = userIds.entrySet().iterator();\n    System.out.println(iterUserIds.next() + \", \" + iterUserIds.hasNext());\n    var entry = iterUserIds.next();\n    System.out.println(entry.getKey() + \"-&gt;\" + entry.getValue() + \", \" + iterUserIds.hasNext());\n    for (var userIdEntry : userIds.entrySet()) {\n      System.out.print(userIdEntry.getKey() + \"-&gt;\" + userIdEntry.getValue());\n      System.out.print(\", \");\n    }\n    System.out.println();\n  }\n}\n</code></pre>"},{"location":"java-tour/#programmation-fonctionnelle","title":"Programmation fonctionnelle","text":"<ul> <li>Les fonctions sont des \u00e9l\u00e9ments de premi\u00e8re classe : Les fonctions sont comme des variables</li> <li>Utilisation intensive de fonctions pures : fonction sans effet de bord, toujours le m\u00eame r\u00e9sultat pour les m\u00eames entr\u00e9es<ul> <li>exemples de fonctions par pure: <code>print</code> (car elle change la console)</li> </ul> </li> <li>Immutabilit\u00e9<ul> <li>On ne peut pas changer la valeur d'une variable une fois initialis\u00e9e</li> <li>On ne peut pas changer les propri\u00e9t\u00e9s d'un object une fois instanci\u00e9</li> <li>On ne peut pas ajouter ou supprimer des \u00e9l\u00e9ments d'une collection</li> </ul> </li> <li>On le code est d\u00e9velopp\u00e9 sous forme d'une cha\u00eene de traitements (comme dans une usine)</li> </ul>"},{"location":"java-tour/#relation-entre-la-poo-et-la-programmation-fonctionnelle","title":"Relation entre la POO et la programmation fonctionnelle","text":"<ul> <li>La POO est la prog. fonctionnelle ne sont pas mutuellement exclusifs</li> <li>On peut d\u00e9velopper en POO avec un style fonctionnelle:<ul> <li>Les m\u00e9thodes ne font pas de mutation de champs de l'objet</li> <li>Les propri\u00e9t\u00e9s sont uniquement en read-only</li> <li>Les <code>records</code> simplifient la cr\u00e9ation de ce genre de classes</li> </ul> </li> </ul>"},{"location":"java-tour/#interfaces-fonctionnelles","title":"Interfaces fonctionnelles","text":"<pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\nimport static java.lang.System.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.function.Predicate;\n\n// L'inteface semble optionnelle\n@FunctionalInterface\ninterface MyCustomBiPredicate {\n  boolean doSomething(int a, int b);\n}\n// equivalent en Kotlin typealias MyCustomPredicate = (Int, Int) -&gt; Boolean ou\n// (Int, Int) -&gt; Boolean\n\npublic class FunctionalInterfaceDemo {\n  static boolean returnFalse(int a, int b) {\n    return false;\n  }\n\n  // Higher order function: a function that takes as argument another function\n  static void callPredicate(MyCustomBiPredicate p) {\n    System.out.println(p.doSomething(10, 0));\n    System.out.println(p.doSomething(0, 0));\n  }\n\n  static List&lt;String&gt; filter(List&lt;String&gt; items, Predicate&lt;String&gt; predicate) {\n    List&lt;String&gt; results = new ArrayList&lt;&gt;();\n    for (String item : items) {\n      if (predicate.test(item)) {\n        results.add(item);\n      }\n    }\n    return results;\n  }\n\n  public static void main(String... args) {\n    MyCustomBiPredicate p = (a, b) -&gt; a &gt; b;\n    System.out.println(p.doSomething(10, 20));\n    p = FunctionalInterfaceDemo::returnFalse;\n    System.out.println(p.doSomething(111, 0));\n\n    callPredicate(p);\n    callPredicate(FunctionalInterfaceDemo::returnFalse);\n    callPredicate((a, b) -&gt; a &gt; b);\n\n    Predicate&lt;Integer&gt; multipleOfThreePredicate = (a) -&gt; a % 3 == 0;\n    Predicate&lt;String&gt; isEmptyPredicate = (s) -&gt; s.length() == 0;\n    System.out.println(multipleOfThreePredicate.test(21));\n    System.out.println(multipleOfThreePredicate.test(65));\n    System.out.println(isEmptyPredicate.test(\"Hello\"));\n    System.out.println(isEmptyPredicate.test(\"\"));\n\n    List&lt;String&gt; words = List.of(\"I\", \"Love\", \"Java\", \"2024\");\n    List&lt;String&gt; items1 = filter(words, (word) -&gt; word.length() == 4);\n    System.out.println(String.join(\" - \", items1));\n    List&lt;String&gt; items2 = filter(words, (w) -&gt; w.charAt(0) == 'J');\n    System.out.println(String.join(\" - \", items2));\n  }\n}\n</code></pre> <p>Equivalent en Kotlin:</p> <pre><code>fun doSomething(a: Int, b: Int) = a &gt; b\n\nclass EntertainmentDevice(val name: String, var releaseYear: Int) {\n  val isAfter2000: Boolean\n    get() = releaseYear &gt;= 2000\n}\n\ntypealias MyCustomPredicate = (Int, Int) -&gt; Boolean\n\nfun main() {\n  val p = ::doSomething\n  println(p(10, 20))\n\n  val p2: (Int, Int) -&gt; Boolean = ::doSomething\n  println(p2(10, 20))\n\n  val p3: MyCustomPredicate = ::doSomething\n}\n</code></pre> <p>Liste des interfaces fonctionnelles pr\u00e9d\u00e9finies qui sont s\u00e9par\u00e9es en 4 cat\u00e9gories:</p> <ul> <li>Consumer : Fonction qui prend des arguments g\u00e9n\u00e9riques et ne renvoie rien (type de retour void)</li> <li>Supplier : Fonction qui ne prend aucun argument et renvoie un valeur dont le type est g\u00e9n\u00e9rique</li> <li>Function : Fonction qui peut prendre des arguments g\u00e9n\u00e9riques et retourne une valeur g\u00e9n\u00e9rique.</li> <li>Predicate : Fonction qui peut prendre des arguments g\u00e9n\u00e9riques et retour un bool\u00e9en. Un predicate peut \u00eatre consid\u00e9r\u00e9 comme un cas particulier d'une Function dont le type de retour est un bool\u00e9en.</li> </ul> <p>La convention est de rajouter le terme bi pour les fonctions avec deux arguments (comme <code>BiPredicate</code>). Voici des exemples de d\u00e9finition de quelques interfaces fonctionnelles:</p> <pre><code>@FunctionalInterface\npublic interface Consumer&lt;T&gt; {\n    void accept(T t);\n}\n\n@FunctionalInterface\npublic interface Supplier&lt;T&gt; {\n    T get();\n}\n\npackage java.util.function;\n@FunctionalInterface\npublic interface Function&lt;T, R&gt; {\n    R apply(T t);\n}\n\n@FunctionalInterface\npublic interface BiFunction&lt;T, U, R&gt; {\n    R apply(T t, U u);\n}\n\n@FunctionalInterface\npublic interface Predicate&lt;T&gt; {\n    boolean test(T t);\n}\n</code></pre>"},{"location":"java-tour/#streams","title":"Streams","text":"<p>Permettent de manipuler des collections de tailles arbitraires de mani\u00e8re d\u00e9clarative.</p> <pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\n//https://navin-moorthy.github.io/blog/map-filter-reduce-animated/\n\nimport static java.lang.System.*;\nimport java.util.*;\nimport java.util.stream.*;\n\npublic class StreamDemo {\n\n  public static void main(String... args) {\n    out.println(\"Hello World\");\n    Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 4, 100);\n    // Imperative programming style: describe how to do\n    List&lt;Integer&gt; r = new ArrayList&lt;&gt;();\n    for (Integer number : numbers.toList()) {\n      if (number % 2 == 0) {\n        r.add(number);\n      }\n    }\n    numbers = Stream.of(1, 2, 3, 4, 100);\n    // Style d\u00e9claratif: describe what we want to do\n    var filteredNumbers = numbers.filter((n) -&gt; n % 2 == 0);\n    var doubleNumbers = filteredNumbers.map((n) -&gt; n * 2);\n    var sum = doubleNumbers.reduce(Integer::sum);\n    System.out.println(sum);\n\n    var otherNumbers = Stream.of(1, 2, 3, 4, 100);\n    var result = otherNumbers\n        .filter((n) -&gt; n % 2 == 0)\n        .map((n) -&gt; n * 2)\n        .reduce((acc, value) -&gt; acc + value);\n\n    System.out.println(result);\n\n    List&lt;Integer&gt; evenNumbers = Stream.of(1, 2, 3, 4, 100)\n        .filter((n) -&gt; n % 2 == 0).toList();\n\n    List&lt;Integer&gt; doubledEvens = evenNumbers.stream().map((n) -&gt; n * 2).toList();\n    var stringDoubles = doubledEvens.stream().map((n) -&gt; n.toString()).toList();\n    System.out.println(String.join(\", \", stringDoubles));\n  }\n}\n</code></pre> <p>Une documentation plus compl\u00e8te est propos\u00e9e le site de baeldung</p>"},{"location":"java-tour/#null-safety","title":"Null safety","text":"<p>D\u00e9finition: la null safety est toute fonctionnalit\u00e9 qui permet de ne plus avoir de null pointer exception \u00e0 l'ex\u00e9cution.</p> <p>Java propose deux possibilit\u00e9s pour aovir une sorte de null safety qui ne sont moins puissantes que ce que l'on peut trouver dans d'autres langages comme Kotlin, Swift ou TypeScript par exemple.</p> Type optionnel<pre><code>///usr/bin/env jbang \"$0\" \"$@\" ; exit $?\n\n// Optional&lt;T&gt; permet d'englober une valeur et fournit des m\u00e9thodes pour la r\u00e9cup\u00e9rer si elle est pr\u00e9sente\n// - Attention: l'objet Optionnel en lui-m\u00eame peut \u00eatre null\n// - En plus, on peut r\u00e9cup\u00e9rer la valeur contenue m\u00eame si elle est null et on aura une exception autre que la NPE\n\nimport static java.lang.System.*;\nimport java.util.*;\n\npublic class OptionalDemo {\n\n  static String getFromInternet() {\n    return \"dsfsdfdsf\";\n  }\n\n  static Optional&lt;String&gt; getFromInternetOpt() {\n    return Optional.of(\"dsfsdfdsf\");\n  }\n\n  public static void main(String... args) {\n    out.println(\"Hello World\");\n\n    Optional&lt;String&gt; myOptionalText = Optional.empty();\n    if (myOptionalText.isPresent()) {\n      System.out.println(myOptionalText.get());\n    }\n    var optioanlValue = getFromInternetOpt();\n    if (optioanlValue.isPresent()) {\n      System.out.println(optioanlValue.get());\n    }\n  }\n}\n</code></pre> Annotations null<pre><code>/*\n * This source file was generated by the Gradle 'init' task\n */\npackage org.example;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\n// Les annotations de nullabilit\u00e9 sont trait\u00e9es par certains IDE et outils pour s'assurer avant la compilation qu'il n'y aura pas de NPE\n// Les IDE g\u00e9n\u00e8rent g\u00e9n\u00e9ralement un avertissement et non une erreur\n// Ces annotations sont ignor\u00e9es par le compilateur Java (au moins jusqu'\u00e0 la version 21)\n// Il y a aussi une multitude d'annotations fournies par diff\u00e9rentes librairies qui peuvent cr\u00e9er de la confusion\n\npublic class App {\n\n  @Nonnull\n  private List&lt;String&gt; items;\n\n  @Nonnull\n  List&lt;String&gt; getItems() {\n    return this.items;\n  }\n\n  public App() {\n    this.items = new ArrayList&lt;&gt;();\n  }\n\n  @Nonnull\n  public String getGreeting() {\n    return \"dsfsdfd\";\n  }\n\n  @Nonnull\n  public String getValue(@Nullable String value) {\n    if (value != null) {\n      return value.toUpperCase();\n    }\n    return \"\";\n  }\n\n  public static void main(String[] args) {\n    @Nonnull\n    App app = new App();\n\n    app.getValue(null);\n\n    System.out.println(app.getItems().size());\n    app.getItems().add(null);\n    app.getItems().add(\"toto\");\n    System.out.println(app.getItems().size());\n  }\n}\n</code></pre>"},{"location":"javafx/","title":"Javafx","text":""},{"location":"javafx/#javafx","title":"JavaFX","text":"<ul> <li>Site officiel: openjfx.io</li> <li>Editeur visuel propos\u00e9 par Gluon ou bien </li> </ul> <pre><code>scoop bucket add extras\nscoop install scene-builder\n</code></pre>"},{"location":"jee/","title":"Jee","text":""},{"location":"jee/#jee","title":"JEE","text":"<p>A compl\u00e9ter</p>"}]}